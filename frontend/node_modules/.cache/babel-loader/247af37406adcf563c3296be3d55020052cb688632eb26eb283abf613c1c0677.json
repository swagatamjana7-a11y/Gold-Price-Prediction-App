{"ast":null,"code":"\"use strict\";\n\nimport bind from \"./helpers/bind.js\";\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {\n  toString\n} = Object.prototype;\nconst {\n  getPrototypeOf\n} = Object;\nconst {\n  iterator,\n  toStringTag\n} = Symbol;\nconst kindOf = (cache => thing => {\n  const str = toString.call(thing);\n  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\nconst kindOfTest = type => {\n  type = type.toLowerCase();\n  return thing => kindOf(thing) === type;\n};\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\r\n * Determine if a value is a non-null object\r\n *\r\n * @param {Object} val The value to test\r\n *\r\n * @returns {boolean} True if value is an Array, otherwise false\r\n */\nconst {\n  isArray\n} = Array;\n\n/**\r\n * Determine if a value is undefined\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if the value is undefined, otherwise false\r\n */\nconst isUndefined = typeOfTest(\"undefined\");\n\n/**\r\n * Determine if a value is a Buffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Buffer, otherwise false\r\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\r\n * Determine if a value is an ArrayBuffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\r\n */\nconst isArrayBuffer = kindOfTest(\"ArrayBuffer\");\n\n/**\r\n * Determine if a value is a view on an ArrayBuffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\r\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n  return result;\n}\n\n/**\r\n * Determine if a value is a String\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a String, otherwise false\r\n */\nconst isString = typeOfTest(\"string\");\n\n/**\r\n * Determine if a value is a Function\r\n *\r\n * @param {*} val The value to test\r\n * @returns {boolean} True if value is a Function, otherwise false\r\n */\nconst isFunction = typeOfTest(\"function\");\n\n/**\r\n * Determine if a value is a Number\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Number, otherwise false\r\n */\nconst isNumber = typeOfTest(\"number\");\n\n/**\r\n * Determine if a value is an Object\r\n *\r\n * @param {*} thing The value to test\r\n *\r\n * @returns {boolean} True if value is an Object, otherwise false\r\n */\nconst isObject = thing => thing !== null && typeof thing === \"object\";\n\n/**\r\n * Determine if a value is a Boolean\r\n *\r\n * @param {*} thing The value to test\r\n * @returns {boolean} True if value is a Boolean, otherwise false\r\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\r\n * Determine if a value is a plain Object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a plain Object, otherwise false\r\n */\nconst isPlainObject = val => {\n  if (kindOf(val) !== \"object\") {\n    return false;\n  }\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n};\n\n/**\r\n * Determine if a value is an empty object (safely handles Buffers)\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is an empty object, otherwise false\r\n */\nconst isEmptyObject = val => {\n  // Early return for non-objects or Buffers to prevent RangeError\n  if (!isObject(val) || isBuffer(val)) {\n    return false;\n  }\n  try {\n    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n  } catch (e) {\n    // Fallback for any other objects that might cause RangeError with Object.keys()\n    return false;\n  }\n};\n\n/**\r\n * Determine if a value is a Date\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Date, otherwise false\r\n */\nconst isDate = kindOfTest(\"Date\");\n\n/**\r\n * Determine if a value is a File\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a File, otherwise false\r\n */\nconst isFile = kindOfTest(\"File\");\n\n/**\r\n * Determine if a value is a Blob\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Blob, otherwise false\r\n */\nconst isBlob = kindOfTest(\"Blob\");\n\n/**\r\n * Determine if a value is a FileList\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a File, otherwise false\r\n */\nconst isFileList = kindOfTest(\"FileList\");\n\n/**\r\n * Determine if a value is a Stream\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Stream, otherwise false\r\n */\nconst isStream = val => isObject(val) && isFunction(val.pipe);\n\n/**\r\n * Determine if a value is a FormData\r\n *\r\n * @param {*} thing The value to test\r\n *\r\n * @returns {boolean} True if value is an FormData, otherwise false\r\n */\nconst isFormData = thing => {\n  let kind;\n  return thing && (typeof FormData === \"function\" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === \"formdata\" ||\n  // detect form-data instance\n  kind === \"object\" && isFunction(thing.toString) && thing.toString() === \"[object FormData]\"));\n};\n\n/**\r\n * Determine if a value is a URLSearchParams object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\r\n */\nconst isURLSearchParams = kindOfTest(\"URLSearchParams\");\nconst [isReadableStream, isRequest, isResponse, isHeaders] = [\"ReadableStream\", \"Request\", \"Response\", \"Headers\"].map(kindOfTest);\n\n/**\r\n * Trim excess whitespace off the beginning and end of a string\r\n *\r\n * @param {String} str The String to trim\r\n *\r\n * @returns {String} The String freed of excess whitespace\r\n */\nconst trim = str => str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n\n/**\r\n * Iterate over an Array or an Object invoking a function for each item.\r\n *\r\n * If `obj` is an Array callback will be called passing\r\n * the value, index, and complete array for each item.\r\n *\r\n * If 'obj' is an Object callback will be called passing\r\n * the value, key, and complete object for each property.\r\n *\r\n * @param {Object|Array<unknown>} obj The object to iterate\r\n * @param {Function} fn The callback to invoke for each item\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.allOwnKeys = false]\r\n * @returns {any}\r\n */\nfunction forEach(obj, fn) {\n  let {\n    allOwnKeys = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === \"undefined\") {\n    return;\n  }\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== \"object\") {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Buffer check\n    if (isBuffer(obj)) {\n      return;\n    }\n\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\nfunction findKey(obj, key) {\n  if (isBuffer(obj)) {\n    return null;\n  }\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : global;\n})();\nconst isContextDefined = context => !isUndefined(context) && context !== _global;\n\n/**\r\n * Accepts varargs expecting each argument to be an object, then\r\n * immutably merges the properties of each object and returns result.\r\n *\r\n * When multiple objects contain the same key the later object in\r\n * the arguments list will take precedence.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * const result = merge({foo: 123}, {foo: 456});\r\n * console.log(result.foo); // outputs 456\r\n * ```\r\n *\r\n * @param {Object} obj1 Object to merge\r\n *\r\n * @returns {Object} Result of all merge properties\r\n */\nfunction merge(/* obj1, obj2, obj3, ... */\n) {\n  const {\n    caseless,\n    skipUndefined\n  } = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    // Skip dangerous property names to prevent prototype pollution\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      return;\n    }\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else if (!skipUndefined || !isUndefined(val)) {\n      result[targetKey] = val;\n    }\n  };\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\r\n * Extends object a by mutably adding to it the properties of object b.\r\n *\r\n * @param {Object} a The object to be extended\r\n * @param {Object} b The object to copy properties from\r\n * @param {Object} thisArg The object to bind function to\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.allOwnKeys]\r\n * @returns {Object} The resulting value of object a\r\n */\nconst extend = function (a, b, thisArg) {\n  let {\n    allOwnKeys\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      Object.defineProperty(a, key, {\n        value: bind(val, thisArg),\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      Object.defineProperty(a, key, {\n        value: val,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }, {\n    allOwnKeys\n  });\n  return a;\n};\n\n/**\r\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\r\n *\r\n * @param {string} content with BOM\r\n *\r\n * @returns {string} content value without BOM\r\n */\nconst stripBOM = content => {\n  if (content.charCodeAt(0) === 0xfeff) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\r\n * Inherit the prototype methods from one constructor into another\r\n * @param {function} constructor\r\n * @param {function} superConstructor\r\n * @param {object} [props]\r\n * @param {object} [descriptors]\r\n *\r\n * @returns {void}\r\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  Object.defineProperty(constructor.prototype, \"constructor\", {\n    value: constructor,\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(constructor, \"super\", {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\r\n * Resolve object with deep prototype chain to a flat object\r\n * @param {Object} sourceObj source object\r\n * @param {Object} [destObj]\r\n * @param {Function|Boolean} [filter]\r\n * @param {Function} [propFilter]\r\n *\r\n * @returns {Object}\r\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n  return destObj;\n};\n\n/**\r\n * Determines whether a string ends with the characters of a specified string\r\n *\r\n * @param {String} str\r\n * @param {String} searchString\r\n * @param {Number} [position= 0]\r\n *\r\n * @returns {boolean}\r\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n/**\r\n * Returns new array from array like object or null if failed\r\n *\r\n * @param {*} [thing]\r\n *\r\n * @returns {?Array}\r\n */\nconst toArray = thing => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\r\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\r\n * thing passed in is an instance of Uint8Array\r\n *\r\n * @param {TypedArray}\r\n *\r\n * @returns {Array}\r\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== \"undefined\" && getPrototypeOf(Uint8Array));\n\n/**\r\n * For each entry in the object, call the function with the key and value.\r\n *\r\n * @param {Object<any, any>} obj - The object to iterate over.\r\n * @param {Function} fn - The function to call for each entry.\r\n *\r\n * @returns {void}\r\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n  const _iterator = generator.call(obj);\n  let result;\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\r\n * It takes a regular expression and a string, and returns an array of all the matches\r\n *\r\n * @param {string} regExp - The regular expression to match against.\r\n * @param {string} str - The string to search.\r\n *\r\n * @returns {Array<boolean>}\r\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest(\"HTMLFormElement\");\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n    return p1.toUpperCase() + p2;\n  });\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (_ref => {\n  let {\n    hasOwnProperty\n  } = _ref;\n  return (obj, prop) => hasOwnProperty.call(obj, prop);\n})(Object.prototype);\n\n/**\r\n * Determine if a value is a RegExp object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a RegExp object, otherwise false\r\n */\nconst isRegExp = kindOfTest(\"RegExp\");\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\r\n * Makes all methods read-only\r\n * @param {Object} obj\r\n */\n\nconst freezeMethods = obj => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && [\"arguments\", \"caller\", \"callee\"].indexOf(name) !== -1) {\n      return false;\n    }\n    const value = obj[name];\n    if (!isFunction(value)) return;\n    descriptor.enumerable = false;\n    if (\"writable\" in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error(\"Can not rewrite read-only method '\" + name + \"'\");\n      };\n    }\n  });\n};\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n  const define = arr => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n  return obj;\n};\nconst noop = () => {};\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n\n/**\r\n * If the thing is a FormData object, return true, otherwise return false.\r\n *\r\n * @param {unknown} thing - The thing to check.\r\n *\r\n * @returns {boolean}\r\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[toStringTag] === \"FormData\" && thing[iterator]);\n}\nconst toJSONObject = obj => {\n  const stack = new Array(10);\n  const visit = (source, i) => {\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      //Buffer check\n      if (isBuffer(source)) {\n        return source;\n      }\n      if (!(\"toJSON\" in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n        stack[i] = undefined;\n        return target;\n      }\n    }\n    return source;\n  };\n  return visit(obj, 0);\n};\nconst isAsyncFn = kindOfTest(\"AsyncFunction\");\nconst isThenable = thing => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", _ref2 => {\n      let {\n        source,\n        data\n      } = _ref2;\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n    return cb => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    };\n  })(\"axios@\".concat(Math.random()), []) : cb => setTimeout(cb);\n})(typeof setImmediate === \"function\", isFunction(_global.postMessage));\nconst asap = typeof queueMicrotask !== \"undefined\" ? queueMicrotask.bind(_global) : typeof process !== \"undefined\" && process.nextTick || _setImmediate;\n\n// *********************\n\nconst isIterable = thing => thing != null && isFunction(thing[iterator]);\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isEmptyObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n};","map":{"version":3,"names":["bind","toString","Object","prototype","getPrototypeOf","iterator","toStringTag","Symbol","kindOf","cache","thing","str","call","slice","toLowerCase","create","kindOfTest","type","typeOfTest","isArray","Array","isUndefined","isBuffer","val","constructor","isFunction","isArrayBuffer","isArrayBufferView","result","ArrayBuffer","isView","buffer","isString","isNumber","isObject","isBoolean","isPlainObject","isEmptyObject","keys","length","e","isDate","isFile","isBlob","isFileList","isStream","pipe","isFormData","kind","FormData","append","isURLSearchParams","isReadableStream","isRequest","isResponse","isHeaders","map","trim","replace","forEach","obj","fn","allOwnKeys","arguments","undefined","i","l","getOwnPropertyNames","len","key","findKey","_key","_global","globalThis","self","window","global","isContextDefined","context","merge","caseless","skipUndefined","assignValue","targetKey","extend","a","b","thisArg","defineProperty","value","writable","enumerable","configurable","stripBOM","content","charCodeAt","inherits","superConstructor","props","descriptors","assign","toFlatObject","sourceObj","destObj","filter","propFilter","prop","merged","endsWith","searchString","position","String","lastIndex","indexOf","toArray","arr","isTypedArray","TypedArray","Uint8Array","forEachEntry","generator","_iterator","next","done","pair","matchAll","regExp","matches","exec","push","isHTMLForm","toCamelCase","replacer","m","p1","p2","toUpperCase","hasOwnProperty","_ref","isRegExp","reduceDescriptors","reducer","getOwnPropertyDescriptors","reducedDescriptors","descriptor","name","ret","defineProperties","freezeMethods","set","Error","toObjectSet","arrayOrString","delimiter","define","split","noop","toFiniteNumber","defaultValue","Number","isFinite","isSpecCompliantForm","toJSONObject","stack","visit","source","target","reducedValue","isAsyncFn","isThenable","then","catch","_setImmediate","setImmediateSupported","postMessageSupported","setImmediate","token","callbacks","addEventListener","_ref2","data","shift","cb","postMessage","concat","Math","random","setTimeout","asap","queueMicrotask","process","nextTick","isIterable","hasOwnProp"],"sources":["D:/CODING/Coder Army Web Dev/Gold-Price-Webapp/frontend/node_modules/axios/lib/utils.js"],"sourcesContent":["\"use strict\";\r\n\r\nimport bind from \"./helpers/bind.js\";\r\n\r\n// utils is a library of generic helper functions non-specific to axios\r\n\r\nconst { toString } = Object.prototype;\r\nconst { getPrototypeOf } = Object;\r\nconst { iterator, toStringTag } = Symbol;\r\n\r\nconst kindOf = ((cache) => (thing) => {\r\n  const str = toString.call(thing);\r\n  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\r\n})(Object.create(null));\r\n\r\nconst kindOfTest = (type) => {\r\n  type = type.toLowerCase();\r\n  return (thing) => kindOf(thing) === type;\r\n};\r\n\r\nconst typeOfTest = (type) => (thing) => typeof thing === type;\r\n\r\n/**\r\n * Determine if a value is a non-null object\r\n *\r\n * @param {Object} val The value to test\r\n *\r\n * @returns {boolean} True if value is an Array, otherwise false\r\n */\r\nconst { isArray } = Array;\r\n\r\n/**\r\n * Determine if a value is undefined\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if the value is undefined, otherwise false\r\n */\r\nconst isUndefined = typeOfTest(\"undefined\");\r\n\r\n/**\r\n * Determine if a value is a Buffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Buffer, otherwise false\r\n */\r\nfunction isBuffer(val) {\r\n  return (\r\n    val !== null &&\r\n    !isUndefined(val) &&\r\n    val.constructor !== null &&\r\n    !isUndefined(val.constructor) &&\r\n    isFunction(val.constructor.isBuffer) &&\r\n    val.constructor.isBuffer(val)\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if a value is an ArrayBuffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\r\n */\r\nconst isArrayBuffer = kindOfTest(\"ArrayBuffer\");\r\n\r\n/**\r\n * Determine if a value is a view on an ArrayBuffer\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\r\n */\r\nfunction isArrayBufferView(val) {\r\n  let result;\r\n  if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\r\n    result = ArrayBuffer.isView(val);\r\n  } else {\r\n    result = val && val.buffer && isArrayBuffer(val.buffer);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Determine if a value is a String\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a String, otherwise false\r\n */\r\nconst isString = typeOfTest(\"string\");\r\n\r\n/**\r\n * Determine if a value is a Function\r\n *\r\n * @param {*} val The value to test\r\n * @returns {boolean} True if value is a Function, otherwise false\r\n */\r\nconst isFunction = typeOfTest(\"function\");\r\n\r\n/**\r\n * Determine if a value is a Number\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Number, otherwise false\r\n */\r\nconst isNumber = typeOfTest(\"number\");\r\n\r\n/**\r\n * Determine if a value is an Object\r\n *\r\n * @param {*} thing The value to test\r\n *\r\n * @returns {boolean} True if value is an Object, otherwise false\r\n */\r\nconst isObject = (thing) => thing !== null && typeof thing === \"object\";\r\n\r\n/**\r\n * Determine if a value is a Boolean\r\n *\r\n * @param {*} thing The value to test\r\n * @returns {boolean} True if value is a Boolean, otherwise false\r\n */\r\nconst isBoolean = (thing) => thing === true || thing === false;\r\n\r\n/**\r\n * Determine if a value is a plain Object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a plain Object, otherwise false\r\n */\r\nconst isPlainObject = (val) => {\r\n  if (kindOf(val) !== \"object\") {\r\n    return false;\r\n  }\r\n\r\n  const prototype = getPrototypeOf(val);\r\n  return (\r\n    (prototype === null ||\r\n      prototype === Object.prototype ||\r\n      Object.getPrototypeOf(prototype) === null) &&\r\n    !(toStringTag in val) &&\r\n    !(iterator in val)\r\n  );\r\n};\r\n\r\n/**\r\n * Determine if a value is an empty object (safely handles Buffers)\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is an empty object, otherwise false\r\n */\r\nconst isEmptyObject = (val) => {\r\n  // Early return for non-objects or Buffers to prevent RangeError\r\n  if (!isObject(val) || isBuffer(val)) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    return (\r\n      Object.keys(val).length === 0 &&\r\n      Object.getPrototypeOf(val) === Object.prototype\r\n    );\r\n  } catch (e) {\r\n    // Fallback for any other objects that might cause RangeError with Object.keys()\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Determine if a value is a Date\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Date, otherwise false\r\n */\r\nconst isDate = kindOfTest(\"Date\");\r\n\r\n/**\r\n * Determine if a value is a File\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a File, otherwise false\r\n */\r\nconst isFile = kindOfTest(\"File\");\r\n\r\n/**\r\n * Determine if a value is a Blob\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Blob, otherwise false\r\n */\r\nconst isBlob = kindOfTest(\"Blob\");\r\n\r\n/**\r\n * Determine if a value is a FileList\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a File, otherwise false\r\n */\r\nconst isFileList = kindOfTest(\"FileList\");\r\n\r\n/**\r\n * Determine if a value is a Stream\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a Stream, otherwise false\r\n */\r\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\r\n\r\n/**\r\n * Determine if a value is a FormData\r\n *\r\n * @param {*} thing The value to test\r\n *\r\n * @returns {boolean} True if value is an FormData, otherwise false\r\n */\r\nconst isFormData = (thing) => {\r\n  let kind;\r\n  return (\r\n    thing &&\r\n    ((typeof FormData === \"function\" && thing instanceof FormData) ||\r\n      (isFunction(thing.append) &&\r\n        ((kind = kindOf(thing)) === \"formdata\" ||\r\n          // detect form-data instance\r\n          (kind === \"object\" &&\r\n            isFunction(thing.toString) &&\r\n            thing.toString() === \"[object FormData]\"))))\r\n  );\r\n};\r\n\r\n/**\r\n * Determine if a value is a URLSearchParams object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\r\n */\r\nconst isURLSearchParams = kindOfTest(\"URLSearchParams\");\r\n\r\nconst [isReadableStream, isRequest, isResponse, isHeaders] = [\r\n  \"ReadableStream\",\r\n  \"Request\",\r\n  \"Response\",\r\n  \"Headers\",\r\n].map(kindOfTest);\r\n\r\n/**\r\n * Trim excess whitespace off the beginning and end of a string\r\n *\r\n * @param {String} str The String to trim\r\n *\r\n * @returns {String} The String freed of excess whitespace\r\n */\r\nconst trim = (str) =>\r\n  str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\r\n\r\n/**\r\n * Iterate over an Array or an Object invoking a function for each item.\r\n *\r\n * If `obj` is an Array callback will be called passing\r\n * the value, index, and complete array for each item.\r\n *\r\n * If 'obj' is an Object callback will be called passing\r\n * the value, key, and complete object for each property.\r\n *\r\n * @param {Object|Array<unknown>} obj The object to iterate\r\n * @param {Function} fn The callback to invoke for each item\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.allOwnKeys = false]\r\n * @returns {any}\r\n */\r\nfunction forEach(obj, fn, { allOwnKeys = false } = {}) {\r\n  // Don't bother if no value provided\r\n  if (obj === null || typeof obj === \"undefined\") {\r\n    return;\r\n  }\r\n\r\n  let i;\r\n  let l;\r\n\r\n  // Force an array if not already something iterable\r\n  if (typeof obj !== \"object\") {\r\n    /*eslint no-param-reassign:0*/\r\n    obj = [obj];\r\n  }\r\n\r\n  if (isArray(obj)) {\r\n    // Iterate over array values\r\n    for (i = 0, l = obj.length; i < l; i++) {\r\n      fn.call(null, obj[i], i, obj);\r\n    }\r\n  } else {\r\n    // Buffer check\r\n    if (isBuffer(obj)) {\r\n      return;\r\n    }\r\n\r\n    // Iterate over object keys\r\n    const keys = allOwnKeys\r\n      ? Object.getOwnPropertyNames(obj)\r\n      : Object.keys(obj);\r\n    const len = keys.length;\r\n    let key;\r\n\r\n    for (i = 0; i < len; i++) {\r\n      key = keys[i];\r\n      fn.call(null, obj[key], key, obj);\r\n    }\r\n  }\r\n}\r\n\r\nfunction findKey(obj, key) {\r\n  if (isBuffer(obj)) {\r\n    return null;\r\n  }\r\n\r\n  key = key.toLowerCase();\r\n  const keys = Object.keys(obj);\r\n  let i = keys.length;\r\n  let _key;\r\n  while (i-- > 0) {\r\n    _key = keys[i];\r\n    if (key === _key.toLowerCase()) {\r\n      return _key;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nconst _global = (() => {\r\n  /*eslint no-undef:0*/\r\n  if (typeof globalThis !== \"undefined\") return globalThis;\r\n  return typeof self !== \"undefined\"\r\n    ? self\r\n    : typeof window !== \"undefined\"\r\n      ? window\r\n      : global;\r\n})();\r\n\r\nconst isContextDefined = (context) =>\r\n  !isUndefined(context) && context !== _global;\r\n\r\n/**\r\n * Accepts varargs expecting each argument to be an object, then\r\n * immutably merges the properties of each object and returns result.\r\n *\r\n * When multiple objects contain the same key the later object in\r\n * the arguments list will take precedence.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * const result = merge({foo: 123}, {foo: 456});\r\n * console.log(result.foo); // outputs 456\r\n * ```\r\n *\r\n * @param {Object} obj1 Object to merge\r\n *\r\n * @returns {Object} Result of all merge properties\r\n */\r\nfunction merge(/* obj1, obj2, obj3, ... */) {\r\n  const { caseless, skipUndefined } = (isContextDefined(this) && this) || {};\r\n  const result = {};\r\n  const assignValue = (val, key) => {\r\n    // Skip dangerous property names to prevent prototype pollution\r\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\r\n      return;\r\n    }\r\n\r\n    const targetKey = (caseless && findKey(result, key)) || key;\r\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\r\n      result[targetKey] = merge(result[targetKey], val);\r\n    } else if (isPlainObject(val)) {\r\n      result[targetKey] = merge({}, val);\r\n    } else if (isArray(val)) {\r\n      result[targetKey] = val.slice();\r\n    } else if (!skipUndefined || !isUndefined(val)) {\r\n      result[targetKey] = val;\r\n    }\r\n  };\r\n\r\n  for (let i = 0, l = arguments.length; i < l; i++) {\r\n    arguments[i] && forEach(arguments[i], assignValue);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Extends object a by mutably adding to it the properties of object b.\r\n *\r\n * @param {Object} a The object to be extended\r\n * @param {Object} b The object to copy properties from\r\n * @param {Object} thisArg The object to bind function to\r\n *\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.allOwnKeys]\r\n * @returns {Object} The resulting value of object a\r\n */\r\nconst extend = (a, b, thisArg, { allOwnKeys } = {}) => {\r\n  forEach(\r\n    b,\r\n    (val, key) => {\r\n      if (thisArg && isFunction(val)) {\r\n        Object.defineProperty(a, key, {\r\n          value: bind(val, thisArg),\r\n          writable: true,\r\n          enumerable: true,\r\n          configurable: true,\r\n        });\r\n      } else {\r\n        Object.defineProperty(a, key, {\r\n          value: val,\r\n          writable: true,\r\n          enumerable: true,\r\n          configurable: true,\r\n        });\r\n      }\r\n    },\r\n    { allOwnKeys },\r\n  );\r\n  return a;\r\n};\r\n\r\n/**\r\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\r\n *\r\n * @param {string} content with BOM\r\n *\r\n * @returns {string} content value without BOM\r\n */\r\nconst stripBOM = (content) => {\r\n  if (content.charCodeAt(0) === 0xfeff) {\r\n    content = content.slice(1);\r\n  }\r\n  return content;\r\n};\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another\r\n * @param {function} constructor\r\n * @param {function} superConstructor\r\n * @param {object} [props]\r\n * @param {object} [descriptors]\r\n *\r\n * @returns {void}\r\n */\r\nconst inherits = (constructor, superConstructor, props, descriptors) => {\r\n  constructor.prototype = Object.create(\r\n    superConstructor.prototype,\r\n    descriptors,\r\n  );\r\n  Object.defineProperty(constructor.prototype, \"constructor\", {\r\n    value: constructor,\r\n    writable: true,\r\n    enumerable: false,\r\n    configurable: true,\r\n  });\r\n  Object.defineProperty(constructor, \"super\", {\r\n    value: superConstructor.prototype,\r\n  });\r\n  props && Object.assign(constructor.prototype, props);\r\n};\r\n\r\n/**\r\n * Resolve object with deep prototype chain to a flat object\r\n * @param {Object} sourceObj source object\r\n * @param {Object} [destObj]\r\n * @param {Function|Boolean} [filter]\r\n * @param {Function} [propFilter]\r\n *\r\n * @returns {Object}\r\n */\r\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\r\n  let props;\r\n  let i;\r\n  let prop;\r\n  const merged = {};\r\n\r\n  destObj = destObj || {};\r\n  // eslint-disable-next-line no-eq-null,eqeqeq\r\n  if (sourceObj == null) return destObj;\r\n\r\n  do {\r\n    props = Object.getOwnPropertyNames(sourceObj);\r\n    i = props.length;\r\n    while (i-- > 0) {\r\n      prop = props[i];\r\n      if (\r\n        (!propFilter || propFilter(prop, sourceObj, destObj)) &&\r\n        !merged[prop]\r\n      ) {\r\n        destObj[prop] = sourceObj[prop];\r\n        merged[prop] = true;\r\n      }\r\n    }\r\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\r\n  } while (\r\n    sourceObj &&\r\n    (!filter || filter(sourceObj, destObj)) &&\r\n    sourceObj !== Object.prototype\r\n  );\r\n\r\n  return destObj;\r\n};\r\n\r\n/**\r\n * Determines whether a string ends with the characters of a specified string\r\n *\r\n * @param {String} str\r\n * @param {String} searchString\r\n * @param {Number} [position= 0]\r\n *\r\n * @returns {boolean}\r\n */\r\nconst endsWith = (str, searchString, position) => {\r\n  str = String(str);\r\n  if (position === undefined || position > str.length) {\r\n    position = str.length;\r\n  }\r\n  position -= searchString.length;\r\n  const lastIndex = str.indexOf(searchString, position);\r\n  return lastIndex !== -1 && lastIndex === position;\r\n};\r\n\r\n/**\r\n * Returns new array from array like object or null if failed\r\n *\r\n * @param {*} [thing]\r\n *\r\n * @returns {?Array}\r\n */\r\nconst toArray = (thing) => {\r\n  if (!thing) return null;\r\n  if (isArray(thing)) return thing;\r\n  let i = thing.length;\r\n  if (!isNumber(i)) return null;\r\n  const arr = new Array(i);\r\n  while (i-- > 0) {\r\n    arr[i] = thing[i];\r\n  }\r\n  return arr;\r\n};\r\n\r\n/**\r\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\r\n * thing passed in is an instance of Uint8Array\r\n *\r\n * @param {TypedArray}\r\n *\r\n * @returns {Array}\r\n */\r\n// eslint-disable-next-line func-names\r\nconst isTypedArray = ((TypedArray) => {\r\n  // eslint-disable-next-line func-names\r\n  return (thing) => {\r\n    return TypedArray && thing instanceof TypedArray;\r\n  };\r\n})(typeof Uint8Array !== \"undefined\" && getPrototypeOf(Uint8Array));\r\n\r\n/**\r\n * For each entry in the object, call the function with the key and value.\r\n *\r\n * @param {Object<any, any>} obj - The object to iterate over.\r\n * @param {Function} fn - The function to call for each entry.\r\n *\r\n * @returns {void}\r\n */\r\nconst forEachEntry = (obj, fn) => {\r\n  const generator = obj && obj[iterator];\r\n\r\n  const _iterator = generator.call(obj);\r\n\r\n  let result;\r\n\r\n  while ((result = _iterator.next()) && !result.done) {\r\n    const pair = result.value;\r\n    fn.call(obj, pair[0], pair[1]);\r\n  }\r\n};\r\n\r\n/**\r\n * It takes a regular expression and a string, and returns an array of all the matches\r\n *\r\n * @param {string} regExp - The regular expression to match against.\r\n * @param {string} str - The string to search.\r\n *\r\n * @returns {Array<boolean>}\r\n */\r\nconst matchAll = (regExp, str) => {\r\n  let matches;\r\n  const arr = [];\r\n\r\n  while ((matches = regExp.exec(str)) !== null) {\r\n    arr.push(matches);\r\n  }\r\n\r\n  return arr;\r\n};\r\n\r\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\r\nconst isHTMLForm = kindOfTest(\"HTMLFormElement\");\r\n\r\nconst toCamelCase = (str) => {\r\n  return str\r\n    .toLowerCase()\r\n    .replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\r\n      return p1.toUpperCase() + p2;\r\n    });\r\n};\r\n\r\n/* Creating a function that will check if an object has a property. */\r\nconst hasOwnProperty = (\r\n  ({ hasOwnProperty }) =>\r\n  (obj, prop) =>\r\n    hasOwnProperty.call(obj, prop)\r\n)(Object.prototype);\r\n\r\n/**\r\n * Determine if a value is a RegExp object\r\n *\r\n * @param {*} val The value to test\r\n *\r\n * @returns {boolean} True if value is a RegExp object, otherwise false\r\n */\r\nconst isRegExp = kindOfTest(\"RegExp\");\r\n\r\nconst reduceDescriptors = (obj, reducer) => {\r\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\r\n  const reducedDescriptors = {};\r\n\r\n  forEach(descriptors, (descriptor, name) => {\r\n    let ret;\r\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\r\n      reducedDescriptors[name] = ret || descriptor;\r\n    }\r\n  });\r\n\r\n  Object.defineProperties(obj, reducedDescriptors);\r\n};\r\n\r\n/**\r\n * Makes all methods read-only\r\n * @param {Object} obj\r\n */\r\n\r\nconst freezeMethods = (obj) => {\r\n  reduceDescriptors(obj, (descriptor, name) => {\r\n    // skip restricted props in strict mode\r\n    if (\r\n      isFunction(obj) &&\r\n      [\"arguments\", \"caller\", \"callee\"].indexOf(name) !== -1\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    const value = obj[name];\r\n\r\n    if (!isFunction(value)) return;\r\n\r\n    descriptor.enumerable = false;\r\n\r\n    if (\"writable\" in descriptor) {\r\n      descriptor.writable = false;\r\n      return;\r\n    }\r\n\r\n    if (!descriptor.set) {\r\n      descriptor.set = () => {\r\n        throw Error(\"Can not rewrite read-only method '\" + name + \"'\");\r\n      };\r\n    }\r\n  });\r\n};\r\n\r\nconst toObjectSet = (arrayOrString, delimiter) => {\r\n  const obj = {};\r\n\r\n  const define = (arr) => {\r\n    arr.forEach((value) => {\r\n      obj[value] = true;\r\n    });\r\n  };\r\n\r\n  isArray(arrayOrString)\r\n    ? define(arrayOrString)\r\n    : define(String(arrayOrString).split(delimiter));\r\n\r\n  return obj;\r\n};\r\n\r\nconst noop = () => {};\r\n\r\nconst toFiniteNumber = (value, defaultValue) => {\r\n  return value != null && Number.isFinite((value = +value))\r\n    ? value\r\n    : defaultValue;\r\n};\r\n\r\n/**\r\n * If the thing is a FormData object, return true, otherwise return false.\r\n *\r\n * @param {unknown} thing - The thing to check.\r\n *\r\n * @returns {boolean}\r\n */\r\nfunction isSpecCompliantForm(thing) {\r\n  return !!(\r\n    thing &&\r\n    isFunction(thing.append) &&\r\n    thing[toStringTag] === \"FormData\" &&\r\n    thing[iterator]\r\n  );\r\n}\r\n\r\nconst toJSONObject = (obj) => {\r\n  const stack = new Array(10);\r\n\r\n  const visit = (source, i) => {\r\n    if (isObject(source)) {\r\n      if (stack.indexOf(source) >= 0) {\r\n        return;\r\n      }\r\n\r\n      //Buffer check\r\n      if (isBuffer(source)) {\r\n        return source;\r\n      }\r\n\r\n      if (!(\"toJSON\" in source)) {\r\n        stack[i] = source;\r\n        const target = isArray(source) ? [] : {};\r\n\r\n        forEach(source, (value, key) => {\r\n          const reducedValue = visit(value, i + 1);\r\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\r\n        });\r\n\r\n        stack[i] = undefined;\r\n\r\n        return target;\r\n      }\r\n    }\r\n\r\n    return source;\r\n  };\r\n\r\n  return visit(obj, 0);\r\n};\r\n\r\nconst isAsyncFn = kindOfTest(\"AsyncFunction\");\r\n\r\nconst isThenable = (thing) =>\r\n  thing &&\r\n  (isObject(thing) || isFunction(thing)) &&\r\n  isFunction(thing.then) &&\r\n  isFunction(thing.catch);\r\n\r\n// original code\r\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\r\n\r\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\r\n  if (setImmediateSupported) {\r\n    return setImmediate;\r\n  }\r\n\r\n  return postMessageSupported\r\n    ? ((token, callbacks) => {\r\n        _global.addEventListener(\r\n          \"message\",\r\n          ({ source, data }) => {\r\n            if (source === _global && data === token) {\r\n              callbacks.length && callbacks.shift()();\r\n            }\r\n          },\r\n          false,\r\n        );\r\n\r\n        return (cb) => {\r\n          callbacks.push(cb);\r\n          _global.postMessage(token, \"*\");\r\n        };\r\n      })(`axios@${Math.random()}`, [])\r\n    : (cb) => setTimeout(cb);\r\n})(typeof setImmediate === \"function\", isFunction(_global.postMessage));\r\n\r\nconst asap =\r\n  typeof queueMicrotask !== \"undefined\"\r\n    ? queueMicrotask.bind(_global)\r\n    : (typeof process !== \"undefined\" && process.nextTick) || _setImmediate;\r\n\r\n// *********************\r\n\r\nconst isIterable = (thing) => thing != null && isFunction(thing[iterator]);\r\n\r\nexport default {\r\n  isArray,\r\n  isArrayBuffer,\r\n  isBuffer,\r\n  isFormData,\r\n  isArrayBufferView,\r\n  isString,\r\n  isNumber,\r\n  isBoolean,\r\n  isObject,\r\n  isPlainObject,\r\n  isEmptyObject,\r\n  isReadableStream,\r\n  isRequest,\r\n  isResponse,\r\n  isHeaders,\r\n  isUndefined,\r\n  isDate,\r\n  isFile,\r\n  isBlob,\r\n  isRegExp,\r\n  isFunction,\r\n  isStream,\r\n  isURLSearchParams,\r\n  isTypedArray,\r\n  isFileList,\r\n  forEach,\r\n  merge,\r\n  extend,\r\n  trim,\r\n  stripBOM,\r\n  inherits,\r\n  toFlatObject,\r\n  kindOf,\r\n  kindOfTest,\r\n  endsWith,\r\n  toArray,\r\n  forEachEntry,\r\n  matchAll,\r\n  isHTMLForm,\r\n  hasOwnProperty,\r\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\r\n  reduceDescriptors,\r\n  freezeMethods,\r\n  toObjectSet,\r\n  toCamelCase,\r\n  noop,\r\n  toFiniteNumber,\r\n  findKey,\r\n  global: _global,\r\n  isContextDefined,\r\n  isSpecCompliantForm,\r\n  toJSONObject,\r\n  isAsyncFn,\r\n  isThenable,\r\n  setImmediate: _setImmediate,\r\n  asap,\r\n  isIterable,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}